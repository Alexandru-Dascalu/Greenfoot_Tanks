#BlueJ class context
comment0.target=Graph
comment0.text=\r\n\ <p><b>File\ name\:\ </b>\ Graph.java\r\n\ @version\ 1.2\r\n\ @since\ 27.07.2018\r\n\ <p><b>Last\ modification\ date\:\ </b>\ 05.10.2018\r\n\ @author\ Alexandru\ F.\ Dascalu\r\n\ <p><b>Copyright\ (C)</b>\ 2018\ \ Alexandru\ F.\ Dascalu\r\n\ \r\n\ <p>Graph.java\ is\ part\ of\ Panzer\ Batallion.\r\n\ Panzer\ Batallion\ is\ free\ software\:\ you\ can\ redistribute\ it\ and/or\ modify\r\n\ it\ under\ the\ terms\ of\ the\ GNU\ General\ Public\ License\ as\ published\ by\r\n\ the\ Free\ Software\ Foundation,\ either\ version\ 3\ of\ the\ License,\ or\r\n\ (at\ your\ option)\ any\ later\ version.\r\n\ \r\n\ <p>This\ program\ is\ distributed\ in\ the\ hope\ that\ it\ will\ be\ useful,\r\n\ but\ WITHOUT\ ANY\ WARRANTY;\ without\ even\ the\ implied\ warranty\ of\r\n\ MERCHANTABILITY\ or\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE.\ \ See\ the\r\n\ GNU\ General\ Public\ License\ for\ more\ details.\r\n\ \r\n\ <p>You\ should\ have\ received\ a\ copy\ of\ the\ GNU\ General\ Public\ License\ v3\r\n\ along\ with\ this\ program.\ \ If\ not,\ see\ <a\ href\="https\://www.gnu.org/licenses/">https\://www.gnu.org/licenses/</a>\ .\r\n\ \r\n\ <p>A\ summary\ of\ the\ license\ can\ be\ found\ here\:\ \r\n\ <a\ href\="https\://choosealicense.com/licenses/gpl-3.0/">https\://choosealicense.com/licenses/gpl-3.0/</a>\ .\r\n\ \r\n\ <p><b>Purpose\:\ </b>\r\n\ <p>\ This\ class\ describes\ a\ graph\ used\ for\ finding\ the\ shortest\ path\ for\ a\ Greenfoot\r\n\ recreation\ of\ the\ Wii\ Tanks\ game\ for\ the\ Nintendo\ Wii.\ It\ builds\ a\ network\ of\r\n\ nodes\ base\ on\ an\ instance\ of\ a\ TankWorld\ so\ that\ nodes\ are\ where\ a\ tank\ can\ move\r\n\ safely\ without\ hitting\ walls.\r\n\ \r\n\ <p><b>Version\ History</b>\r\n\ <p>\t-1.0\ -\ Created\ the\ class.\r\n\ <p>\t-1.1\ -\ Added\ code\ to\ generate\ paths\ that\ avoid\ land\ mines.\r\n\ <p>\t-1.2\ -\ Changed\ the\ way\ paths\ for\ avoiding\ mines\ are\ computed\ so\ as\ to\ not\r\n\ repeat\ code\ in\ the\ getPathAvoidingMine\ method.\ The\ getter\ for\ points\ in\ the\ \r\n\ matrix\ now\ returns\ a\ non\ null\ neighbour\ if\ the\ point\ at\ the\ given\ coordinates\r\n\ is\ null,\ and\ some\ minor\ refactoring\ to\ avoid\ exceptions.\r\n
comment1.params=tankWorld
comment1.target=Graph(TankWorld)
comment1.text=\r\n\ Makes\ a\ new\ Graph\ that\ matches\ the\ layout\ of\ the\ given\ instance\ of\ TankWorld.\r\n\ This\ means\ it\ will\ make\ a\ graph\ where\ if\ a\ point\ in\ the\ world\ is\ too\ close\ to\r\n\ a\ wall,\ it\ will\ be\ a\ null\ value\ in\ the\ matrix\ so\ that\ the\ tank\ will\ not\ \r\n\ pass\ through\ walls.\ It\ also\ adds\ the\ edges\ between\ neighbouring\ nodes\ while\r\n\ making\ new\ nodes.\r\n\ @param\ tankWorld\ The\ world\ this\ graph\ is\ built\ for.\r\n
comment10.params=rowIndex\ columnIndex
comment10.target=boolean\ indexesOutOfBounds(int,\ int)
comment10.text=\r\n\ Checks\ if\ the\ given\ indexes\ are\ within\ the\ bounds\ of\ the\ point\ matrix\r\n\ of\ this\ graph.\r\n\ @param\ rowIndex\ The\ row\ index\ to\ be\ checked.\r\n\ @param\ columnIndex\ The\ column\ index\ to\ be\ checked.\r\n\ @return\ True\ if\ they\ are\ out\ of\ bounds,\ false\ if\ not.\r\n
comment2.params=startX\ startY\ target
comment2.target=java.util.LinkedList\ getShortestPath(int,\ int,\ GraphPoint)
comment2.text=\r\n\ Computes\ the\ shortest\ path\ between\ the\ given\ coordinates\ in\ the\ game\ \r\n\ world\ and\ the\ target\ node\ in\ this\ graph\ using\ Diejkstr'a\ algorithm.\r\n\ @param\ startX\ The\ starting\ x\ coordinate.\r\n\ @param\ startY\ The\ starting\ y\ coordinate.\r\n\ @param\ target\ The\ node\ in\ the\ graph\ that\ is\ the\ destination.\r\n\ @return\ A\ LinkedList\ of\ graph\ nodes\ (GraphPoint\ objects)\ that\ is\ the\ \r\n\ shortest\ path\ to\ the\ target\ node.\r\n
comment3.params=tank\ mine\ target
comment3.target=java.util.LinkedList\ getPathAvoidingMine(MobileEnemyTank,\ LandMine,\ GraphPoint)
comment3.text=\r\n\ Computes\ the\ shortest\ path\ between\ the\ given\ coordinates\ in\ the\ game\ \r\n\ world\ and\ the\ target\ node\ in\ this\ graph\ using\ the\ Diejkstr'a\ algorithm,\ \r\n\ while\ keeping\ a\ safe\ distance\ from\ the\ given\ land\ mine.\r\n\ @param\ target\ The\ node\ in\ the\ graph\ that\ is\ the\ destination.\r\n\ @param\ tank\ The\ tank\ for\ which\ this\ path\ is\ computed.\r\n\ @param\ mine\ The\ mine\ that\ will\ be\ avoided\ by\ the\ returned\ path.\r\n\ @return\ A\ LinkedList\ of\ graph\ nodes\ (GraphPoint\ objects)\ that\ is\ the\ \r\n\ shortest\ path\ to\ the\ target\ node.\r\n
comment4.params=startX\ startY
comment4.target=GraphPoint\ initializeSourcePoint(int,\ int)
comment4.text=\r\n\ Finds\ the\ node\ in\ the\ graph\ closest\ to\ the\ given\ coordinates\ in\ the\ game\r\n\ world\ and\ initialises\ it's\ tentative\ distance.\r\n\ @param\ startX\ The\ starting\ x\ coordinate.\r\n\ @param\ startY\ The\ starting\ y\ coordinate.\r\n
comment5.params=target
comment5.target=java.util.LinkedList\ getPath(GraphPoint)
comment5.text=\r\n\ Builds\ and\ returns\ the\ linked\ list\ that\ is\ the\ path\ between\ the\ source\r\n\ point\ and\ the\ target\ node.\r\n\ @param\ target\ The\ target\ node\ the\ tank\ will\ move\ to.\r\n\ @return\ The\ linked\ list\ of\ nodes\ in\ the\ graph\ starting\ from\ the\ source\r\n\ to\ the\ destination\ node.\r\n
comment6.params=
comment6.target=void\ resetGraph()
comment6.text=Resets\ the\ graph\ to\ prepare\ for\ the\ next\ call\ of\ the\ getShortestPath.
comment7.params=mine\ avoidanceDistance\ current
comment7.target=void\ visitNodesCloseToMine(LandMine,\ int,\ GraphPoint)
comment7.text=\r\n\ Recursively\ checks\ if\ the\ nodes\ around\ the\ given\ mine\ are\ at\ a\ safe\r\n\ distance\ away\ from\ the\ mine.\ If\ they\ are\ not,\ they\ are\ marked\ as\ \r\n\ visited\ so\ they\ will\ not\ be\ considered\ by\ the\ shortest\ path\ \r\n\ algorithm.\ The\ node\ given\ as\ an\ argument\ is\ marked\ as\ visited\ or\ not,\ \r\n\ then\ the\ method\ is\ called\ on\ all\ it's\ unvisited\ neighbours.\r\n\ @param\ mine\ The\ mine\ that\ the\ nodes\ need\ to\ be\ at\ a\ safe\ distance\ away\r\n\ from\ to\ be\ considered\ in\ the\ shortest\ path\ algorithm.\r\n\ @param\ avoidanceDistance\ The\ safe\ distance\ nodes\ need\ to\ be\ away\ from\ to\r\n\ be\ considered\ in\ the\ shortest\ path\ algorithm.\r\n\ @param\ current\ The\ current\ node\ being\ considered\ in\ the\ recursion.\r\n
comment8.params=x\ y
comment8.target=GraphPoint\ getPoint(int,\ int)
comment8.text=\r\n\ Getter\ for\ individual\ nodes\ of\ this\ graph.\ Returns\ the\ node\ whose\ point\r\n\ it\ represents\ is\ at\ the\ given\ coordinates\ in\ the\ world,\ or\ if\ at\ those\ \r\n\ coordinates\ the\ slot\ in\ the\ matrix\ is\ null,\ it\ will\ return\ the\ first\ \r\n\ non\ null\ neighbour\ of\ it.\r\n\ @param\ x\ The\ row\ index\ of\ the\ node\ to\ be\ returned.\r\n\ @param\ y\ The\ column\ index\ of\ the\ node\ to\ be\ returned.\r\n\ @return\ The\ point\ in\ the\ matrix\ at\ the\ given\ indexes.\r\n
comment9.params=rowIndex\ columnIndex
comment9.target=GraphPoint\ getNonNullNeighbour(int,\ int)
comment9.text=\r\n\ Gets\ the\ first\ non\ null\ neighbour\ encountered\ of\ a\ given\ point\ in\ the\ \r\n\ matrix.\r\n\ Useful\ when\ a\ given\ slot\ in\ the\ matrix\ is\ null\ and\ we\ need\ a\ neighbouring\ \r\n\ node\ that\ is\ not\ null.\r\n\ @param\ rowIndex\ The\ row\ index\ of\ the\ point\ in\ the\ matrix.\r\n\ @param\ columnIndex\ The\ column\ index\ of\ the\ point\ in\ the\ matrix.\r\n\ @return\ The\ first\ non\ null\ neighbour\ of\ the\ point\ in\ the\ matrix\ at\ the\ \r\n\ given\ coordinates.\r\n
numComments=11
